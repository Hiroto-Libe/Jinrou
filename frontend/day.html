<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>昼フェーズ - 議論＆投票</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --castle-bg-1: #f1e7d6;
      --castle-bg-2: #d2c0a0;
      --castle-bg-3: #b59c78;
      --castle-ink: #2b2b2b;
      --castle-panel: #f8f1e3;
      --castle-border: #d1c0a2;
      --castle-shadow: rgba(27, 20, 10, 0.15);
    }
    body {
      font-family: "Yu Gothic", "Yu Gothic UI", "Meiryo", sans-serif;
      margin: 16px;
      color: var(--castle-ink);
      background:
        radial-gradient(1200px 600px at 10% -10%, rgba(255,255,255,0.55), rgba(255,255,255,0)),
        radial-gradient(900px 500px at 100% 0%, rgba(0,0,0,0.08), rgba(0,0,0,0)),
        linear-gradient(160deg, var(--castle-bg-1), var(--castle-bg-2) 60%, var(--castle-bg-3));
    }
    h1 { font-size: 1.4rem; margin: 0 0 8px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    .box {
      background: var(--castle-panel);
      border: 1px solid var(--castle-border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 6px 16px var(--castle-shadow);
    }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .status { margin-top:6px; color:#444; }
    .note { margin-top:6px; color:#666; font-size:.88rem; }
    .banner {
      margin-top:8px;
      padding:8px 10px;
      border-radius:10px;
      background: #efe2c9;
      border: 1px solid #d7c2a2;
      font-size:.9rem;
    }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; font-size:.82rem; color:#333; }

    .members {
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap:8px;
      margin-top:10px;
    }
    .member-card{
      border:1px solid #ccc; border-radius:10px; padding:8px;
      background:#fff; cursor:pointer; user-select:none;
      display:flex; flex-direction:column; gap:4px;
      min-height:72px;
    }
    .member-card.dead { opacity:.4; cursor:not-allowed; }
    .member-card.disabled { opacity:.5; cursor:not-allowed; }
    .member-card.self { outline:2px dashed #bbb; }
    .member-card.selected { border-color:#0066cc; box-shadow:0 0 0 2px rgba(0,102,204,.18); }
    .name { font-weight:600; }
    .sub { font-size:.78rem; color:#777; }

    button { padding:10px 14px; border-radius:999px; border:none; font-size:1rem; }
    .primary { background:#0066cc; color:#fff; }
    .ghost { background:#eee; color:#333; }
    .danger { background:#b00020; color:#fff; }
    button:disabled { opacity:.5; }

    .log { margin-top:10px; white-space:pre-wrap; font-size:.92rem; }
    .error { color:#b00020; }
    .success { color:#006400; }

    table { width:100%; border-collapse:collapse; margin-top:10px; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; font-size:.95rem; }
    th { color:#666; font-weight:600; }
  </style>
</head>
<body>
  <h1>昼フェーズ：議論＆投票</h1>

  <div class="grid">
    <div class="box">
      <div class="row" style="justify-content:space-between">
        <div>
          <div>あなた：<strong id="me-name">（読み込み中）</strong></div>
          <div class="status" id="status">読み込み中...</div>
          <div class="note" id="host-note"></div>
          <div class="banner" id="runoff-note" style="display:none;"></div>
        </div>
        <div class="row">
          <button class="ghost" id="refresh">更新</button>
          <button class="ghost" id="to-night">夜（役職画面）へ</button>
        </div>
      </div>
    </div>

    <div class="box">
      <div class="row" style="justify-content:space-between">
        <div>
          <div style="font-weight:600;">投票（DAY_DISCUSSION のときのみ）</div>
          <div class="status" id="vote-status">対象を選んで投票してください。</div>
        </div>
        <div class="row">
          <button class="primary" id="vote-btn" disabled>この人に投票する</button>
          <button class="ghost" id="tally-btn">集計を見る</button>
          <button class="danger" id="resolve-day">処刑を確定</button>
        </div>
      </div>

      <div id="members" class="members"></div>
      <div id="log" class="log"></div>
    </div>

    <div class="box">
      <div style="font-weight:600;">投票集計</div>
      <div id="tally-area" class="status">まだ集計していません。</div>
    </div>
  </div>

  <!-- ★重要：外部JS読み込み（src付きscriptの中身は実行されないので分離する） -->
  <script src="/frontend/js/night_common.js"></script>

  <script>
    const qs = new URLSearchParams(location.search);
    const gameId = qs.get("game_id");
    const playerId = qs.get("player_id");

    // ★追加：勝敗確定なら result.html へ（初期表示保険）
    setupAutoResultRedirect(gameId, playerId);

    const statusEl = document.getElementById("status");
    const hostNoteEl = document.getElementById("host-note");
    const runoffNoteEl = document.getElementById("runoff-note");
    const meNameEl = document.getElementById("me-name");
    const voteStatusEl = document.getElementById("vote-status");
    const membersEl = document.getElementById("members");
    const logEl = document.getElementById("log");
    const tallyArea = document.getElementById("tally-area");

    const voteBtn = document.getElementById("vote-btn");
    const resolveBtn = document.getElementById("resolve-day");
    const tallyBtn = document.getElementById("tally-btn");
    const toNightBtn = document.getElementById("to-night");

    let me = null;
    let members = [];
    let selected = null;
    let selectedId = null;

    function jump(path) {
      location.href = `/frontend/${path}?game_id=${encodeURIComponent(gameId)}&player_id=${encodeURIComponent(playerId)}`;
    }

    function log(msg, type) {
      const div = document.createElement("div");
      div.textContent = msg;
      if (type) div.className = type;
      logEl.appendChild(div);
    }

    async function fetchGame() {
      const res = await fetch(`/api/games/${encodeURIComponent(gameId)}`);
      if (!res.ok) throw new Error(`game取得失敗(${res.status})`);
      return await res.json();
    }

    async function fetchMe() {
      const res = await fetch(`/api/games/${encodeURIComponent(gameId)}/me?player_id=${encodeURIComponent(playerId)}`);
      if (!res.ok) throw new Error(`me取得失敗(${res.status})`);
      return await res.json();
    }

    async function fetchMembers() {
      const res = await fetch(`/api/games/${encodeURIComponent(gameId)}/members`);
      if (!res.ok) throw new Error(`members取得失敗(${res.status})`);
      return await res.json();
    }

    async function fetchDayVoteStatus() {
      const res = await fetch(`/api/games/${encodeURIComponent(gameId)}/day_vote_status`);
      if (!res.ok) throw new Error(`day_vote_status取得失敗(${res.status})`);
      return await res.json();
    }

    function renderMembers(canVote, candidateIds = []) {
      membersEl.innerHTML = "";
      const selfId = me?.player_id || me?.game_member_id;
      let foundSelected = false;
      const isRunoff = Array.isArray(candidateIds) && candidateIds.length > 0;

      members.forEach(m => {
        const card = document.createElement("div");
        card.className = "member-card";

        const alive = (m.alive !== false) && (m.is_alive !== false);
        const isSelf = selfId && m.id === selfId;

        if (!alive) card.classList.add("dead");
        if (isSelf) card.classList.add("self");

        const name = m.display_name || m.name || "（名無し）";

        const nameDiv = document.createElement("div");
        nameDiv.className = "name";
        nameDiv.textContent = name;

        const subDiv = document.createElement("div");
        subDiv.className = "sub";
        const meIsWolf = (me?.role === "wolf" || me?.role === "werewolf");
        const isWolfAlly = m.role_type === "WEREWOLF";

        const isRunoffCandidate = !isRunoff || candidateIds.includes(m.id);
        if (!alive) subDiv.textContent = "死亡";
        else if (isSelf) subDiv.textContent = "あなた（自投票は可/不可は運用次第）";
        else if (!isRunoffCandidate) subDiv.textContent = "決選投票の対象外";
        else if (meIsWolf && isWolfAlly) subDiv.textContent = "同じ人狼には投票できません";
        else subDiv.textContent = "タップして投票対象に選択";

        card.appendChild(nameDiv);
        card.appendChild(subDiv);

        // 仕様：死者は投票対象にできない。投票可能状態でなければクリック不可
        if (!alive || !canVote || !isRunoffCandidate || (meIsWolf && isWolfAlly)) {
          card.style.pointerEvents = "none";
          card.style.opacity = alive ? 0.85 : 0.4;
          if (meIsWolf && isWolfAlly) card.classList.add("disabled");
        } else {
          card.addEventListener("click", () => {
            membersEl.querySelectorAll(".member-card").forEach(el => el.classList.remove("selected"));
            card.classList.add("selected");
            selected = m;
            selectedId = m.id;
            voteBtn.disabled = false;
            voteStatusEl.textContent = `投票先：${name}`;
          });
        }

        if (canVote && selectedId && m.id === selectedId) {
          card.classList.add("selected");
          selected = m;
          voteBtn.disabled = false;
          voteStatusEl.textContent = `投票先：${name}`;
          foundSelected = true;
        }

        membersEl.appendChild(card);
      });

      if (!foundSelected) {
        selectedId = null;
      }
    }

    async function sync() {
      selected = null;
      voteBtn.disabled = true;

      if (!gameId || !playerId) {
        statusEl.textContent = "game_id / player_id がURLにありません。";
        return;
      }

      try {
        const g = await fetchGame();
        const st = String(g.status || "").toUpperCase();
        const tallyDayNo = (st === "NIGHT")
          ? Math.max(1, (g.curr_day || 1) - 1)
          : (g.curr_day || 1);
        const prevTallyDay = Number(tallyArea.dataset.tallyDay || "0");
        if (!prevTallyDay) {
          tallyArea.textContent = "まだ集計していません。";
          tallyArea.dataset.tallyDay = String(tallyDayNo);
        }
        if (prevTallyDay && tallyDayNo > prevTallyDay) {
          tallyArea.textContent = "まだ集計していません。";
          tallyArea.dataset.tallyDay = String(tallyDayNo);
        }

        const [meData, membersData] = await Promise.all([fetchMe(), fetchMembers()]);
        me = meData;
        members = membersData;

        // 表示名
        const selfId = me?.player_id || me?.game_member_id;
        const meMember = members.find(x => x.id === selfId);
        meNameEl.textContent = meMember?.display_name || meMember?.name || "あなた";
        const isAlive = (meMember?.alive !== false) && (meMember?.is_alive !== false);
        if (!isAlive) {
          jump("spectator.html");
          return;
        }

        const canVote = (st === "DAY_DISCUSSION");
        const isHost = !!me?.is_host;
        let voteStatus = null;
        if (canVote) {
          try {
            voteStatus = await fetchDayVoteStatus();
          } catch (_) {
            voteStatus = null;
          }
        }
        const allVoted = !!voteStatus?.all_done;
        statusEl.innerHTML = `ゲーム状態：<span class="pill">${st}</span> / 司会：${isHost ? "あなた" : "別の人"}`;
        if (!isHost && canVote) {
          hostNoteEl.textContent = "司会が処刑を確定します";
          hostNoteEl.style.display = "block";
        } else {
          hostNoteEl.textContent = "";
          hostNoteEl.style.display = "none";
        }
        voteBtn.disabled = !canVote;
        resolveBtn.style.display = (canVote && isHost) ? "inline-flex" : "none";
        resolveBtn.disabled = !canVote || !isHost || !allVoted;
        if (!isHost) {
          resolveBtn.title = "司会のみ実行できます";
        } else if (!canVote) {
          resolveBtn.title = "DAY_DISCUSSIONのときのみ実行できます";
        } else if (!allVoted) {
          const voted = voteStatus?.voted_count ?? 0;
          const total = voteStatus?.alive_total ?? 0;
          resolveBtn.title = `投票完了待ち（${voted}/${total}）`;
        } else {
          resolveBtn.title = "";
        }
        tallyBtn.disabled = false;

        if (st === "NIGHT") {
          const executedId = g.last_executed_member_id;
          const executedMember = members.find(x => x.id === executedId);
          const executedName = executedMember?.display_name || executedMember?.name || "不明";
          voteStatusEl.textContent = executedId
            ? `本日の処刑結果：${executedName}（夜へ進むボタンを押してください）`
            : "夜に移行しました。夜へ進むボタンを押してください。";
          tallyBtn.classList.add("primary");
          tallyBtn.classList.remove("ghost");
          tallyBtn.textContent = "集計を見る（結果確認）";
          toNightBtn.classList.add("primary");
          toNightBtn.classList.remove("ghost");
          toNightBtn.textContent = "夜へ進む";
          toNightBtn.disabled = !isAlive;
          toNightBtn.title = isAlive ? "" : "死亡したプレイヤーは夜へ進めません";
        } else {
          voteStatusEl.textContent = canVote
            ? "対象を選んで投票してください。"
            : `投票できない状態です（現在：${st}）。`;
          tallyBtn.classList.remove("primary");
          tallyBtn.classList.add("ghost");
          tallyBtn.textContent = "集計を見る";
          toNightBtn.classList.remove("primary");
          toNightBtn.classList.add("ghost");
          toNightBtn.textContent = "夜へ進む";
          toNightBtn.disabled = true;
          toNightBtn.title = "処刑確定後に押せます";
        }

        if (voteStatus?.is_runoff) {
          voteStatusEl.textContent = "決選投票：同数トップの候補から選んで投票してください。";
          tallyBtn.textContent = "集計を見る";
          tallyBtn.classList.remove("primary");
          tallyBtn.classList.add("ghost");
          if (runoffNoteEl) {
            runoffNoteEl.textContent = "決選投票に移行しました。候補者から再投票してください。";
            runoffNoteEl.style.display = "block";
          }
        } else if (runoffNoteEl) {
          runoffNoteEl.textContent = "";
          runoffNoteEl.style.display = "none";
        }

        renderMembers(canVote, voteStatus?.candidate_ids || []);
        await redirectIfFinished(gameId, playerId);
      } catch (e) {
        console.error(e);
        log(String(e), "error");
      }
    }

    async function doVote() {
      if (!selected || !me) return;

      try {
        const body = {
          voter_member_id: me.player_id,        // /me の player_id は GameMember.id
          target_member_id: selected.id,
        };

        const res = await fetch(`/api/games/${encodeURIComponent(gameId)}/day_vote`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          log(`投票に失敗しました(${res.status}): ${JSON.stringify(data)}`, "error");
          return;
        }
        await sync();
        log("投票しました。", "success");

        // ★追加：投票後に勝敗確定してたら結果へ
        await redirectIfFinished(gameId, playerId);
      } catch (e) {
        console.error(e);
        log(String(e), "error");
      }
    }

    async function showTally() {
      tallyArea.textContent = "集計中...";
      try {
        const g = await fetchGame();
        const st = String(g.status || "").toUpperCase();
        const dayNo = (st === "NIGHT")
          ? Math.max(1, (g.curr_day || 1) - 1)
          : (g.curr_day || 1);
        const res = await fetch(`/api/games/${encodeURIComponent(gameId)}/day_tally?day_no=${encodeURIComponent(dayNo)}`);
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          tallyArea.innerHTML = `<div class="error">集計取得失敗(${res.status}): ${JSON.stringify(data)}</div>`;
          return;
        }

        const items = Array.isArray(data.items) ? data.items : [];
        if (!items.length) {
          tallyArea.textContent = "まだ票がありません。";
          return;
        }

        const idToName = new Map(members.map(m => [m.id, (m.display_name || m.name || m.id)]));

        const rows = items
          .slice()
          .sort((a,b) => (b.vote_count||0) - (a.vote_count||0))
          .map(it => `<tr><td>${idToName.get(it.target_member_id) || it.target_member_id}</td><td>${it.vote_count}</td></tr>`)
          .join("");

        tallyArea.innerHTML = `
          <table>
            <thead><tr><th>対象</th><th>票数</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        `;
        tallyArea.dataset.tallyDay = String(dayNo);
      } catch (e) {
        console.error(e);
        tallyArea.innerHTML = `<div class="error">${String(e)}</div>`;
      }
    }

    async function resolveDay() {
      // 司会運用想定：処刑確定→夜へ
      try {
        const g = await fetchGame();
        const st = String(g.status || "").toUpperCase();
        if (st !== "DAY_DISCUSSION") {
          log(`DAY_DISCUSSIONではありません（現在：${st}）。`, "error");
          return;
        }

        const res = await fetch(`/api/games/${encodeURIComponent(gameId)}/resolve_day_simple`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ requester_member_id: me.player_id }),
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          log(`処刑確定に失敗しました(${res.status}): ${JSON.stringify(data)}`, "error");
          return;
        }

        if (data.status === "RUNOFF") {
          log("同数のため決選投票に移行しました。", "success");
          await sync();
          await showTally();
          return;
        }

        log("処刑を確定しました。結果を確認してから夜へ進んでください。", "success");

        // ★追加：処刑で勝敗確定するので最重要
        await redirectIfFinished(gameId, playerId);

        // resolve_day_simple が NIGHT に進めるので、結果確認後に手動で夜へ進む
        await sync();
        await showTally();
      } catch (e) {
        console.error(e);
        log(String(e), "error");
      }
    }

    document.getElementById("refresh").addEventListener("click", sync);
    async function goNightDirect() {
      try {
        if (!me) me = await fetchMe();
        const role = me?.role;
        if (role === "seer") return jump("seer_night.html");
        if (role === "knight") return jump("knight_night.html");
        if (role === "wolf" || role === "werewolf") return jump("night_wolf_attack.html");
        return jump("night_wait.html");
      } catch (e) {
        console.error(e);
        log("夜画面への移動に失敗しました。", "error");
      }
    }

    document.getElementById("to-night").addEventListener("click", goNightDirect);
    voteBtn.addEventListener("click", doVote);
    document.getElementById("tally-btn").addEventListener("click", showTally);
    resolveBtn.addEventListener("click", resolveDay);

    // 状態変化を追う（夜になったら自動で夜へ）
    setInterval(sync, 1500);
    sync();
  </script>
</body>
</html>
